// Code generated by proto-gen-dao. DO NOT EDIT.
// source: github.com/vine-io/raft/example/proto/hello.proto

package pb

import (
	context "context"
	errors "errors"
	_ "github.com/vine-io/apimachinery/apis/meta/v1"
	runtime "github.com/vine-io/apimachinery/runtime"
	apistorage "github.com/vine-io/apimachinery/storage"
	dao "github.com/vine-io/vine/lib/dao"
	clause "github.com/vine-io/vine/lib/dao/clause"
	time "time"
)

func init() {
	store[SchemeGroupVersion.WithKind("Epoch")] = &EpochStorage{}
	store[SchemeGroupVersion.WithKind("Product")] = &ProductStorage{}
}

// EpochStorage the Storage for Epoch
type EpochStorage struct {
	tx    *dao.DB             `json:"-" dao:"-"`
	exprs []clause.Expression `json:"-" dao:"-"`

	Kind                   string `json:"kind,omitempty" dao:"column:kind"`
	ApiVersion             string `json:"apiVersion,omitempty" dao:"column:api_version"`
	Id                     string `json:"id,omitempty" dao:"column:id;primaryKey"`
	Term                   int64  `json:"term,omitempty" dao:"column:term"`
	Index                  int64  `json:"index,omitempty" dao:"column:index"`
	InnerDeletionTimestamp int64  `json:"innerDeletionTimestamp,omitempty" dao:"column:inner_deletion_timestamp"`
}

func (m *EpochStorage) AutoMigrate() error {
	return dao.DefaultDialect.Migrator().AutoMigrate(m)
}

func (m *EpochStorage) Load(object runtime.Object) error {
	in, ok := object.(*Epoch)
	if !ok {
		return apistorage.ErrInvalidObject
	}

	*m = *FromEpoch(in).(*EpochStorage)
	return nil
}

func (m *EpochStorage) WithTx(tx *dao.DB) *EpochStorage {
	m.tx = tx
	return m
}
func RegisterEpoch() error {
	return dao.DefaultDialect.Migrator().AutoMigrate(&EpochStorage{})
}

func EpochStorageBuilder() *EpochStorage {
	return &EpochStorage{tx: dao.DefaultDialect.NewTx()}
}

func (m *EpochStorage) SetKind(in string) *EpochStorage {
	m.Kind = in
	return m
}

func (m *EpochStorage) SetApiVersion(in string) *EpochStorage {
	m.ApiVersion = in
	return m
}

func (m *EpochStorage) SetId(in string) *EpochStorage {
	m.Id = in
	return m
}

func (m *EpochStorage) SetTerm(in int64) *EpochStorage {
	m.Term = in
	return m
}

func (m *EpochStorage) SetIndex(in int64) *EpochStorage {
	m.Index = in
	return m
}

func FromEpoch(obj runtime.Object) apistorage.Storage {
	in := obj.(*Epoch)
	out := new(EpochStorage)
	out.tx = dao.DefaultDialect.NewTx()
	if in.Kind != "" {
		out.Kind = in.Kind
	}
	if in.ApiVersion != "" {
		out.ApiVersion = in.ApiVersion
	}
	if in.Id != "" {
		out.Id = in.Id
	}
	if in.Term != 0 {
		out.Term = in.Term
	}
	if in.Index != 0 {
		out.Index = in.Index
	}
	return out
}

func (m *EpochStorage) ToEpoch() *Epoch {
	out := new(Epoch)
	out.Kind = m.Kind
	out.ApiVersion = m.ApiVersion
	out.Id = m.Id
	out.Term = m.Term
	out.Index = m.Index
	return out
}

func (EpochStorage) TableName() string {
	return "epoches"
}

func (m EpochStorage) PrimaryKey() (string, interface{}, bool) {
	return "id", m.Id, m.Id == ""
}

func (m *EpochStorage) FindPage(ctx context.Context, page, size int32) ([]runtime.Object, int64, error) {
	pk, _, _ := m.PrimaryKey()

	m.exprs = append(m.exprs,
		clause.OrderBy{Columns: []clause.OrderByColumn{{Column: clause.Column{Table: m.TableName(), Name: pk}, Desc: true}}},
		clause.Cond().Build("inner_deletion_timestamp", 0),
	)

	total, err := m.Count(ctx)
	if err != nil {
		return nil, 0, err
	}

	m.exprs = append(m.exprs, clause.Limit{Offset: int((page - 1) * size), Limit: int(size)})
	data, err := m.findAll(ctx)
	if err != nil {
		return nil, 0, err
	}

	return data, total, nil
}

func (m *EpochStorage) FindAll(ctx context.Context) ([]runtime.Object, error) {
	m.exprs = append(m.exprs, clause.Cond().Build("inner_deletion_timestamp", 0))
	return m.findAll(ctx)
}

func (m *EpochStorage) FindPureAll(ctx context.Context) ([]runtime.Object, error) {
	return m.findAll(ctx)
}

func (m *EpochStorage) findAll(ctx context.Context) ([]runtime.Object, error) {
	dest := make([]*EpochStorage, 0)
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(m.extractClauses(tx), m.exprs...)
	if err := tx.Clauses(clauses...).Find(&dest).Error; err != nil {
		return nil, err
	}

	outs := make([]runtime.Object, len(dest))
	for i := range dest {
		outs[i] = dest[i].ToEpoch()
	}

	return outs, nil
}

func (m *EpochStorage) FindEntitiesPage(ctx context.Context, page, size int) ([]*Epoch, int64, error) {
	pk, _, _ := m.PrimaryKey()

	m.exprs = append(m.exprs,
		clause.OrderBy{Columns: []clause.OrderByColumn{{Column: clause.Column{Table: m.TableName(), Name: pk}, Desc: true}}},
		clause.Cond().Build("inner_deletion_timestamp", 0),
	)

	total, err := m.Count(ctx)
	if err != nil {
		return nil, 0, err
	}

	m.exprs = append(m.exprs, clause.Limit{Offset: int((page - 1) * size), Limit: int(size)})
	data, err := m.findAllEntities(ctx)
	if err != nil {
		return nil, 0, err
	}

	return data, total, nil
}

func (m *EpochStorage) FindAllEntities(ctx context.Context) ([]*Epoch, error) {
	m.exprs = append(m.exprs, clause.Cond().Build("inner_deletion_timestamp", 0))
	return m.findAllEntities(ctx)
}

func (m *EpochStorage) FindPureAllEntities(ctx context.Context) ([]*Epoch, error) {
	return m.findAllEntities(ctx)
}

func (m *EpochStorage) findAllEntities(ctx context.Context) ([]*Epoch, error) {
	dest := make([]*EpochStorage, 0)
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(m.extractClauses(tx), m.exprs...)
	if err := tx.Clauses(clauses...).Find(&dest).Error; err != nil {
		return nil, err
	}

	outs := make([]*Epoch, len(dest))
	for i := range dest {
		outs[i] = dest[i].ToEpoch()
	}

	return outs, nil
}

func (m *EpochStorage) Count(ctx context.Context) (total int64, err error) {
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(m.extractClauses(tx), clause.Cond().Build("inner_deletion_timestamp", 0))
	clauses = append(clauses, m.exprs...)

	err = tx.Clauses(clauses...).Count(&total).Error
	return
}

func (m *EpochStorage) FindOne(ctx context.Context) (runtime.Object, error) {
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(m.extractClauses(tx), clause.Cond().Build("inner_deletion_timestamp", 0))
	clauses = append(clauses, m.exprs...)

	if err := tx.Clauses(clauses...).First(&m).Error; err != nil {
		return nil, err
	}

	return m.ToEpoch(), nil
}

func (m *EpochStorage) FindPureOne(ctx context.Context) (runtime.Object, error) {
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Clauses(m.exprs...).First(&m).Error; err != nil {
		return nil, err
	}

	return m.ToEpoch(), nil
}

func (m *EpochStorage) Cond(exprs ...clause.Expression) apistorage.Storage {
	m.exprs = append(m.exprs, exprs...)
	return m
}

func (m *EpochStorage) extractClauses(tx *dao.DB) []clause.Expression {
	exprs := make([]clause.Expression, 0)
	if m.Kind != "" {
		exprs = append(exprs, clause.Cond().Op(clause.ParseOp(m.Kind)).Build("kind", m.Kind))
	}
	if m.ApiVersion != "" {
		exprs = append(exprs, clause.Cond().Op(clause.ParseOp(m.ApiVersion)).Build("api_version", m.ApiVersion))
	}
	if m.Id != "" {
		exprs = append(exprs, clause.Cond().Op(clause.ParseOp(m.Id)).Build("id", m.Id))
	}
	if m.Term != 0 {
		exprs = append(exprs, clause.Cond().Build("term", m.Term))
	}
	if m.Index != 0 {
		exprs = append(exprs, clause.Cond().Build("index", m.Index))
	}

	return exprs
}

func (m *EpochStorage) Create(ctx context.Context) (runtime.Object, error) {
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Create(m).Error; err != nil {
		return nil, err
	}

	return m.ToEpoch(), nil
}

func (m *EpochStorage) BatchUpdates(ctx context.Context) error {
	if len(m.exprs) == 0 {
		return errors.New("missing conditions")
	}

	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	values := make(map[string]interface{}, 0)
	if m.Kind != "" {
		values["kind"] = m.Kind
	}
	if m.ApiVersion != "" {
		values["api_version"] = m.ApiVersion
	}
	if m.Term != 0 {
		values["term"] = m.Term
	}
	if m.Index != 0 {
		values["index"] = m.Index
	}

	return tx.Clauses(m.exprs...).Updates(values).Error
}

func (m *EpochStorage) Updates(ctx context.Context) (runtime.Object, error) {
	pk, pkv, isNil := m.PrimaryKey()
	if isNil {
		return nil, errors.New("missing primary key")
	}

	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx).Where(pk+" = ?", pkv)

	values := make(map[string]interface{}, 0)
	if m.Kind != "" {
		values["kind"] = m.Kind
	}
	if m.ApiVersion != "" {
		values["api_version"] = m.ApiVersion
	}
	if m.Term != 0 {
		values["term"] = m.Term
	}
	if m.Index != 0 {
		values["index"] = m.Index
	}

	if err := tx.Updates(values).Error; err != nil {
		return nil, err
	}

	err := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx).Where(pk+" = ?", pkv).First(m).Error
	if err != nil {
		return nil, err
	}
	return m.ToEpoch(), nil
}

func (m *EpochStorage) BatchDelete(ctx context.Context, soft bool) error {
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)
	clauses := append(m.exprs, m.extractClauses(tx)...)

	if soft {
		return tx.Clauses(clauses...).Updates(map[string]interface{}{"inner_deletion_timestamp": time.Now().UnixNano()}).Error
	}
	return tx.Clauses(clauses...).Delete(&EpochStorage{}).Error
}

func (m *EpochStorage) Delete(ctx context.Context, soft bool) error {
	pk, pkv, isNil := m.PrimaryKey()
	if isNil {
		return errors.New("missing primary key")
	}

	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	if soft {
		return tx.Where(pk+" = ?", pkv).Updates(map[string]interface{}{"inner_deletion_timestamp": time.Now().UnixNano()}).Error
	}
	return tx.Where(pk+" = ?", pkv).Delete(&EpochStorage{}).Error
}

func (m *EpochStorage) Tx(ctx context.Context) *dao.DB {
	return m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx).Clauses(m.exprs...)
}

// ProductStorage the Storage for Product
type ProductStorage struct {
	tx    *dao.DB             `json:"-" dao:"-"`
	exprs []clause.Expression `json:"-" dao:"-"`

	Kind                   string `json:"kind,omitempty" dao:"column:kind"`
	ApiVersion             string `json:"apiVersion,omitempty" dao:"column:api_version"`
	Id                     string `json:"id,omitempty" dao:"column:id;primaryKey"`
	Date                   int64  `json:"date,omitempty" dao:"column:date"`
	Company                string `json:"company,omitempty" dao:"column:company"`
	InnerDeletionTimestamp int64  `json:"innerDeletionTimestamp,omitempty" dao:"column:inner_deletion_timestamp"`
}

func (m *ProductStorage) AutoMigrate() error {
	return dao.DefaultDialect.Migrator().AutoMigrate(m)
}

func (m *ProductStorage) Load(object runtime.Object) error {
	in, ok := object.(*Product)
	if !ok {
		return apistorage.ErrInvalidObject
	}

	*m = *FromProduct(in).(*ProductStorage)
	return nil
}

func (m *ProductStorage) WithTx(tx *dao.DB) *ProductStorage {
	m.tx = tx
	return m
}
func RegisterProduct() error {
	return dao.DefaultDialect.Migrator().AutoMigrate(&ProductStorage{})
}

func ProductStorageBuilder() *ProductStorage {
	return &ProductStorage{tx: dao.DefaultDialect.NewTx()}
}

func (m *ProductStorage) SetKind(in string) *ProductStorage {
	m.Kind = in
	return m
}

func (m *ProductStorage) SetApiVersion(in string) *ProductStorage {
	m.ApiVersion = in
	return m
}

func (m *ProductStorage) SetId(in string) *ProductStorage {
	m.Id = in
	return m
}

func (m *ProductStorage) SetDate(in int64) *ProductStorage {
	m.Date = in
	return m
}

func (m *ProductStorage) SetCompany(in string) *ProductStorage {
	m.Company = in
	return m
}

func FromProduct(obj runtime.Object) apistorage.Storage {
	in := obj.(*Product)
	out := new(ProductStorage)
	out.tx = dao.DefaultDialect.NewTx()
	if in.Kind != "" {
		out.Kind = in.Kind
	}
	if in.ApiVersion != "" {
		out.ApiVersion = in.ApiVersion
	}
	if in.Id != "" {
		out.Id = in.Id
	}
	if in.Date != 0 {
		out.Date = in.Date
	}
	if in.Company != "" {
		out.Company = in.Company
	}
	return out
}

func (m *ProductStorage) ToProduct() *Product {
	out := new(Product)
	out.Kind = m.Kind
	out.ApiVersion = m.ApiVersion
	out.Id = m.Id
	out.Date = m.Date
	out.Company = m.Company
	return out
}

func (ProductStorage) TableName() string {
	return "products"
}

func (m ProductStorage) PrimaryKey() (string, interface{}, bool) {
	return "id", m.Id, m.Id == ""
}

func (m *ProductStorage) FindPage(ctx context.Context, page, size int32) ([]runtime.Object, int64, error) {
	pk, _, _ := m.PrimaryKey()

	m.exprs = append(m.exprs,
		clause.OrderBy{Columns: []clause.OrderByColumn{{Column: clause.Column{Table: m.TableName(), Name: pk}, Desc: true}}},
		clause.Cond().Build("inner_deletion_timestamp", 0),
	)

	total, err := m.Count(ctx)
	if err != nil {
		return nil, 0, err
	}

	m.exprs = append(m.exprs, clause.Limit{Offset: int((page - 1) * size), Limit: int(size)})
	data, err := m.findAll(ctx)
	if err != nil {
		return nil, 0, err
	}

	return data, total, nil
}

func (m *ProductStorage) FindAll(ctx context.Context) ([]runtime.Object, error) {
	m.exprs = append(m.exprs, clause.Cond().Build("inner_deletion_timestamp", 0))
	return m.findAll(ctx)
}

func (m *ProductStorage) FindPureAll(ctx context.Context) ([]runtime.Object, error) {
	return m.findAll(ctx)
}

func (m *ProductStorage) findAll(ctx context.Context) ([]runtime.Object, error) {
	dest := make([]*ProductStorage, 0)
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(m.extractClauses(tx), m.exprs...)
	if err := tx.Clauses(clauses...).Find(&dest).Error; err != nil {
		return nil, err
	}

	outs := make([]runtime.Object, len(dest))
	for i := range dest {
		outs[i] = dest[i].ToProduct()
	}

	return outs, nil
}

func (m *ProductStorage) FindEntitiesPage(ctx context.Context, page, size int) ([]*Product, int64, error) {
	pk, _, _ := m.PrimaryKey()

	m.exprs = append(m.exprs,
		clause.OrderBy{Columns: []clause.OrderByColumn{{Column: clause.Column{Table: m.TableName(), Name: pk}, Desc: true}}},
		clause.Cond().Build("inner_deletion_timestamp", 0),
	)

	total, err := m.Count(ctx)
	if err != nil {
		return nil, 0, err
	}

	m.exprs = append(m.exprs, clause.Limit{Offset: int((page - 1) * size), Limit: int(size)})
	data, err := m.findAllEntities(ctx)
	if err != nil {
		return nil, 0, err
	}

	return data, total, nil
}

func (m *ProductStorage) FindAllEntities(ctx context.Context) ([]*Product, error) {
	m.exprs = append(m.exprs, clause.Cond().Build("inner_deletion_timestamp", 0))
	return m.findAllEntities(ctx)
}

func (m *ProductStorage) FindPureAllEntities(ctx context.Context) ([]*Product, error) {
	return m.findAllEntities(ctx)
}

func (m *ProductStorage) findAllEntities(ctx context.Context) ([]*Product, error) {
	dest := make([]*ProductStorage, 0)
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(m.extractClauses(tx), m.exprs...)
	if err := tx.Clauses(clauses...).Find(&dest).Error; err != nil {
		return nil, err
	}

	outs := make([]*Product, len(dest))
	for i := range dest {
		outs[i] = dest[i].ToProduct()
	}

	return outs, nil
}

func (m *ProductStorage) Count(ctx context.Context) (total int64, err error) {
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(m.extractClauses(tx), clause.Cond().Build("inner_deletion_timestamp", 0))
	clauses = append(clauses, m.exprs...)

	err = tx.Clauses(clauses...).Count(&total).Error
	return
}

func (m *ProductStorage) FindOne(ctx context.Context) (runtime.Object, error) {
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(m.extractClauses(tx), clause.Cond().Build("inner_deletion_timestamp", 0))
	clauses = append(clauses, m.exprs...)

	if err := tx.Clauses(clauses...).First(&m).Error; err != nil {
		return nil, err
	}

	return m.ToProduct(), nil
}

func (m *ProductStorage) FindPureOne(ctx context.Context) (runtime.Object, error) {
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Clauses(m.exprs...).First(&m).Error; err != nil {
		return nil, err
	}

	return m.ToProduct(), nil
}

func (m *ProductStorage) Cond(exprs ...clause.Expression) apistorage.Storage {
	m.exprs = append(m.exprs, exprs...)
	return m
}

func (m *ProductStorage) extractClauses(tx *dao.DB) []clause.Expression {
	exprs := make([]clause.Expression, 0)
	if m.Kind != "" {
		exprs = append(exprs, clause.Cond().Op(clause.ParseOp(m.Kind)).Build("kind", m.Kind))
	}
	if m.ApiVersion != "" {
		exprs = append(exprs, clause.Cond().Op(clause.ParseOp(m.ApiVersion)).Build("api_version", m.ApiVersion))
	}
	if m.Id != "" {
		exprs = append(exprs, clause.Cond().Op(clause.ParseOp(m.Id)).Build("id", m.Id))
	}
	if m.Date != 0 {
		exprs = append(exprs, clause.Cond().Build("date", m.Date))
	}
	if m.Company != "" {
		exprs = append(exprs, clause.Cond().Op(clause.ParseOp(m.Company)).Build("company", m.Company))
	}

	return exprs
}

func (m *ProductStorage) Create(ctx context.Context) (runtime.Object, error) {
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Create(m).Error; err != nil {
		return nil, err
	}

	return m.ToProduct(), nil
}

func (m *ProductStorage) BatchUpdates(ctx context.Context) error {
	if len(m.exprs) == 0 {
		return errors.New("missing conditions")
	}

	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	values := make(map[string]interface{}, 0)
	if m.Kind != "" {
		values["kind"] = m.Kind
	}
	if m.ApiVersion != "" {
		values["api_version"] = m.ApiVersion
	}
	if m.Date != 0 {
		values["date"] = m.Date
	}
	if m.Company != "" {
		values["company"] = m.Company
	}

	return tx.Clauses(m.exprs...).Updates(values).Error
}

func (m *ProductStorage) Updates(ctx context.Context) (runtime.Object, error) {
	pk, pkv, isNil := m.PrimaryKey()
	if isNil {
		return nil, errors.New("missing primary key")
	}

	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx).Where(pk+" = ?", pkv)

	values := make(map[string]interface{}, 0)
	if m.Kind != "" {
		values["kind"] = m.Kind
	}
	if m.ApiVersion != "" {
		values["api_version"] = m.ApiVersion
	}
	if m.Date != 0 {
		values["date"] = m.Date
	}
	if m.Company != "" {
		values["company"] = m.Company
	}

	if err := tx.Updates(values).Error; err != nil {
		return nil, err
	}

	err := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx).Where(pk+" = ?", pkv).First(m).Error
	if err != nil {
		return nil, err
	}
	return m.ToProduct(), nil
}

func (m *ProductStorage) BatchDelete(ctx context.Context, soft bool) error {
	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)
	clauses := append(m.exprs, m.extractClauses(tx)...)

	if soft {
		return tx.Clauses(clauses...).Updates(map[string]interface{}{"inner_deletion_timestamp": time.Now().UnixNano()}).Error
	}
	return tx.Clauses(clauses...).Delete(&ProductStorage{}).Error
}

func (m *ProductStorage) Delete(ctx context.Context, soft bool) error {
	pk, pkv, isNil := m.PrimaryKey()
	if isNil {
		return errors.New("missing primary key")
	}

	tx := m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx)

	if soft {
		return tx.Where(pk+" = ?", pkv).Updates(map[string]interface{}{"inner_deletion_timestamp": time.Now().UnixNano()}).Error
	}
	return tx.Where(pk+" = ?", pkv).Delete(&ProductStorage{}).Error
}

func (m *ProductStorage) Tx(ctx context.Context) *dao.DB {
	return m.tx.Session(&dao.Session{}).Table(m.TableName()).WithContext(ctx).Clauses(m.exprs...)
}
