// Code generated by proto-gen-dao. DO NOT EDIT.
// source: github.com/vine-io/raft/examples/proto/hello.proto

package pb

import (
	context "context"
	errors "errors"
	_ "github.com/vine-io/apimachinery/apis/meta/v1"
	runtime "github.com/vine-io/apimachinery/runtime"
	apistorage "github.com/vine-io/apimachinery/storage"
	dao "github.com/vine-io/apimachinery/storage/dao"
	gorm "gorm.io/gorm"
	clause "gorm.io/gorm/clause"
	reflect "reflect"
	time "time"
)

// /Users/xingyys/project/gopath/src/github.com/vine-io/raft/examples/proto
func init() {
	storageSet = append(storageSet,
		&ProductStorage{},
		&EpochStorage{},
	)
}
func (m *Epoch) SetKind(in string) *Epoch {
	m.Kind = in
	return m
}

func (m *Epoch) SetApiVersion(in string) *Epoch {
	m.ApiVersion = in
	return m
}

func (m *Epoch) SetId(in string) *Epoch {
	m.Id = in
	return m
}

func (m *Epoch) SetTerm(in int64) *Epoch {
	m.Term = in
	return m
}

func (m *Epoch) SetIndex(in int64) *Epoch {
	m.Index = in
	return m
}

type XXEpoch struct {
	Kind                   string `json:"kind,omitempty" gorm:"column:kind"`
	ApiVersion             string `json:"apiVersion,omitempty" gorm:"column:api_version"`
	Id                     string `json:"id,omitempty" gorm:"column:id"`
	Term                   int64  `json:"term,omitempty" gorm:"column:term"`
	Index                  int64  `json:"index,omitempty" gorm:"column:index"`
	InnerDeletionTimestamp int64  `json:"innerDeletionTimestamp,omitempty" gorm:"column:inner_deletion_timestamp"`
}

func FromEpoch(in *Epoch) *XXEpoch {
	out := new(XXEpoch)
	if in.Kind != "" {
		out.Kind = in.Kind
	}
	if in.ApiVersion != "" {
		out.ApiVersion = in.ApiVersion
	}
	if in.Id != "" {
		out.Id = in.Id
	}
	if in.Term != 0 {
		out.Term = in.Term
	}
	if in.Index != 0 {
		out.Index = in.Index
	}
	return out
}

func (m *XXEpoch) ToEpoch() *Epoch {
	out := new(Epoch)
	out.Kind = m.Kind
	out.ApiVersion = m.ApiVersion
	out.Id = m.Id
	out.Term = m.Term
	out.Index = m.Index
	return out
}

func (m XXEpoch) PrimaryKey() (string, any, bool) {
	return "id", m.Id, m.Id == ""
}

func (XXEpoch) TableName() string {
	return "epoches"
}

// EpochStorage the Storage for Epoch
type EpochStorage struct {
	tx    *gorm.DB `json:"-" gorm:"-"`
	joins []string `json:"-" gorm:"-"`
	m     XXEpoch
	exprs []clause.Expression `json:"-" gorm:"-"`
}

func NewEpochStorage(tx *gorm.DB, m *Epoch) *EpochStorage {
	return &EpochStorage{tx: tx, joins: []string{}, exprs: make([]clause.Expression, 0), m: *FromEpoch(m)}
}
func (s *EpochStorage) AutoMigrate(tx *gorm.DB) error {
	return tx.Migrator().AutoMigrate(&XXEpoch{})
}

func (s EpochStorage) Target() reflect.Type {
	return reflect.TypeOf(new(Epoch))
}

func (s *EpochStorage) Load(tx *gorm.DB, in runtime.Object) error {
	return s.XXLoad(tx, in.(*Epoch))
}
func (s *EpochStorage) FindPage(ctx context.Context, page, size int32) (runtime.Object, error) {
	items, total, err := s.XXFindPage(ctx, page, size)
	if err != nil {
		return nil, err
	}

	out := &EpochList{}
	out.Page = page
	out.Size = size
	out.Total = total
	out.Items = items
	if len(items) > 0 {
		out.TypeMeta = items[0].TypeMeta
	}
	return out, nil
}

func (s *EpochStorage) FindAll(ctx context.Context) (runtime.Object, error) {
	items, err := s.XXFindAll(ctx)
	if err != nil {
		return nil, err
	}

	out := &EpochList{}
	out.Total = int64(len(items))
	out.Items = items
	if len(items) > 0 {
		out.TypeMeta = items[0].TypeMeta
	}
	return out, nil
}

func (s *EpochStorage) FindPk(ctx context.Context, id any) (runtime.Object, error) {
	return s.XXFindPk(ctx, id)
}

func (s *EpochStorage) FindOne(ctx context.Context) (runtime.Object, error) {
	return s.XXFindOne(ctx)
}

func (s *EpochStorage) Cond(exprs ...clause.Expression) apistorage.Storage {
	return s.XXCond(exprs...)
}

func (s *EpochStorage) Create(ctx context.Context) (runtime.Object, error) {
	return s.XXCreate(ctx)
}

func (s *EpochStorage) Updates(ctx context.Context) (runtime.Object, error) {
	return s.XXUpdates(ctx)
}

func (s *EpochStorage) Delete(ctx context.Context, soft bool) error {
	return s.XXDelete(ctx, soft)
}

func (s *EpochStorage) XXLoad(tx *gorm.DB, in *Epoch) error {
	s.tx = tx
	s.m = *FromEpoch(in)
	return nil
}

func (s *EpochStorage) XXFindPage(ctx context.Context, page, size int32) ([]*Epoch, int64, error) {
	m := s.m
	pk, _, _ := m.PrimaryKey()

	s.exprs = append(s.exprs,
		clause.OrderBy{Columns: []clause.OrderByColumn{{Column: clause.Column{Table: m.TableName(), Name: pk}, Desc: true}}},
		dao.Cond().Build("inner_deletion_timestamp", 0),
	)

	total, err := s.Count(ctx)
	if err != nil {
		return nil, 0, err
	}

	limit := int(size)
	s.exprs = append(s.exprs, clause.Limit{Offset: int((page - 1) * size), Limit: &limit})
	data, err := s.findAll(ctx)
	if err != nil {
		return nil, 0, err
	}

	return data, total, nil
}

func (s *EpochStorage) XXFindAll(ctx context.Context) ([]*Epoch, error) {
	s.exprs = append(s.exprs, dao.Cond().Build("inner_deletion_timestamp", 0))
	return s.findAll(ctx)
}

func (s *EpochStorage) XXFindPureAll(ctx context.Context) ([]*Epoch, error) {
	return s.findAll(ctx)
}

func (s *EpochStorage) findAll(ctx context.Context) ([]*Epoch, error) {
	dest := make([]*XXEpoch, 0)
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(s.extractClauses(tx), s.exprs...)
	for _, item := range s.joins {
		tx = tx.Joins(item)
	}
	if err := tx.Clauses(clauses...).Find(&dest).Error; err != nil {
		return nil, err
	}

	outs := make([]*Epoch, len(dest))
	for i := range dest {
		outs[i] = dest[i].ToEpoch()
	}

	return outs, nil
}

func (s *EpochStorage) Count(ctx context.Context) (total int64, err error) {
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(s.extractClauses(tx), dao.Cond().Build("inner_deletion_timestamp", 0))
	clauses = append(clauses, s.exprs...)

	err = tx.Clauses(clauses...).Count(&total).Error
	return
}

func (s *EpochStorage) XXFindPk(ctx context.Context, id any) (*Epoch, error) {
	m := s.m
	pk, _, _ := m.PrimaryKey()
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Where(pk+" = ?", id).First(&m).Error; err != nil {
		return nil, err
	}
	return m.ToEpoch(), nil
}

func (s *EpochStorage) XXFindOne(ctx context.Context) (*Epoch, error) {
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(s.extractClauses(tx), dao.Cond().Build("inner_deletion_timestamp", 0))
	clauses = append(clauses, s.exprs...)

	for _, item := range s.joins {
		tx = tx.Joins(item)
	}
	if err := tx.Clauses(clauses...).First(&m).Error; err != nil {
		return nil, err
	}

	return m.ToEpoch(), nil
}

func (s *EpochStorage) XXFindPureOne(ctx context.Context) (*Epoch, error) {
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Clauses(s.exprs...).First(&m).Error; err != nil {
		return nil, err
	}

	return m.ToEpoch(), nil
}

func (s *EpochStorage) XXCond(exprs ...clause.Expression) *EpochStorage {
	s.exprs = append(s.exprs, exprs...)
	return s
}

func (s *EpochStorage) extractClauses(tx *gorm.DB) []clause.Expression {
	m := s.m
	exprs := make([]clause.Expression, 0)
	if m.Kind != "" {
		exprs = append(exprs, dao.Cond().Op(dao.ParseOp(m.Kind)).Build("kind", m.Kind))
	}
	if m.ApiVersion != "" {
		exprs = append(exprs, dao.Cond().Op(dao.ParseOp(m.ApiVersion)).Build("api_version", m.ApiVersion))
	}
	if m.Id != "" {
		exprs = append(exprs, dao.Cond().Op(dao.ParseOp(m.Id)).Build("id", m.Id))
	}
	if m.Term != 0 {
		exprs = append(exprs, dao.Cond().Build("term", m.Term))
	}
	if m.Index != 0 {
		exprs = append(exprs, dao.Cond().Build("index", m.Index))
	}

	return exprs
}

func (s *EpochStorage) XXCreate(ctx context.Context) (*Epoch, error) {
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Create(m).Error; err != nil {
		return nil, err
	}

	return m.ToEpoch(), nil
}

func (s *EpochStorage) XXUpdates(ctx context.Context) (*Epoch, error) {
	m := s.m
	pk, pkv, isNil := m.PrimaryKey()
	if isNil {
		return nil, errors.New("missing primary key")
	}

	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx).Where(pk+" = ?", pkv)

	values := make(map[string]interface{}, 0)
	if m.Kind != "" {
		values["kind"] = m.Kind
	}
	if m.ApiVersion != "" {
		values["api_version"] = m.ApiVersion
	}
	if m.Term != 0 {
		values["term"] = m.Term
	}
	if m.Index != 0 {
		values["index"] = m.Index
	}

	if err := tx.Updates(values).Error; err != nil {
		return nil, err
	}

	err := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx).Where(pk+" = ?", pkv).First(m).Error
	if err != nil {
		return nil, err
	}
	return m.ToEpoch(), nil
}

func (s *EpochStorage) XXDelete(ctx context.Context, soft bool) error {
	m := s.m
	pk, pkv, isNil := m.PrimaryKey()
	if isNil {
		return errors.New("missing primary key")
	}

	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	if soft {
		return tx.Where(pk+" = ?", pkv).Updates(map[string]interface{}{"inner_deletion_timestamp": time.Now().UnixNano()}).Error
	}
	return tx.Where(pk+" = ?", pkv).Delete(&EpochStorage{}).Error
}

func (m *Product) SetKind(in string) *Product {
	m.Kind = in
	return m
}

func (m *Product) SetApiVersion(in string) *Product {
	m.ApiVersion = in
	return m
}

func (m *Product) SetId(in string) *Product {
	m.Id = in
	return m
}

func (m *Product) SetDate(in int64) *Product {
	m.Date = in
	return m
}

func (m *Product) SetCompany(in string) *Product {
	m.Company = in
	return m
}

type XXProduct struct {
	Kind                   string `json:"kind,omitempty" gorm:"column:kind"`
	ApiVersion             string `json:"apiVersion,omitempty" gorm:"column:api_version"`
	Id                     string `json:"id,omitempty" gorm:"column:id"`
	Date                   int64  `json:"date,omitempty" gorm:"column:date"`
	Company                string `json:"company,omitempty" gorm:"column:company"`
	InnerDeletionTimestamp int64  `json:"innerDeletionTimestamp,omitempty" gorm:"column:inner_deletion_timestamp"`
}

func FromProduct(in *Product) *XXProduct {
	out := new(XXProduct)
	if in.Kind != "" {
		out.Kind = in.Kind
	}
	if in.ApiVersion != "" {
		out.ApiVersion = in.ApiVersion
	}
	if in.Id != "" {
		out.Id = in.Id
	}
	if in.Date != 0 {
		out.Date = in.Date
	}
	if in.Company != "" {
		out.Company = in.Company
	}
	return out
}

func (m *XXProduct) ToProduct() *Product {
	out := new(Product)
	out.Kind = m.Kind
	out.ApiVersion = m.ApiVersion
	out.Id = m.Id
	out.Date = m.Date
	out.Company = m.Company
	return out
}

func (m XXProduct) PrimaryKey() (string, any, bool) {
	return "id", m.Id, m.Id == ""
}

func (XXProduct) TableName() string {
	return "products"
}

// ProductStorage the Storage for Product
type ProductStorage struct {
	tx    *gorm.DB `json:"-" gorm:"-"`
	joins []string `json:"-" gorm:"-"`
	m     XXProduct
	exprs []clause.Expression `json:"-" gorm:"-"`
}

func NewProductStorage(tx *gorm.DB, m *Product) *ProductStorage {
	return &ProductStorage{tx: tx, joins: []string{}, exprs: make([]clause.Expression, 0), m: *FromProduct(m)}
}
func (s *ProductStorage) AutoMigrate(tx *gorm.DB) error {
	return tx.Migrator().AutoMigrate(&XXProduct{})
}

func (s ProductStorage) Target() reflect.Type {
	return reflect.TypeOf(new(Product))
}

func (s *ProductStorage) Load(tx *gorm.DB, in runtime.Object) error {
	return s.XXLoad(tx, in.(*Product))
}
func (s *ProductStorage) FindPage(ctx context.Context, page, size int32) (runtime.Object, error) {
	items, total, err := s.XXFindPage(ctx, page, size)
	if err != nil {
		return nil, err
	}

	out := &ProductList{}
	out.Page = page
	out.Size = size
	out.Total = total
	out.Items = items
	if len(items) > 0 {
		out.TypeMeta = items[0].TypeMeta
	}
	return out, nil
}

func (s *ProductStorage) FindAll(ctx context.Context) (runtime.Object, error) {
	items, err := s.XXFindAll(ctx)
	if err != nil {
		return nil, err
	}

	out := &ProductList{}
	out.Total = int64(len(items))
	out.Items = items
	if len(items) > 0 {
		out.TypeMeta = items[0].TypeMeta
	}
	return out, nil
}

func (s *ProductStorage) FindPk(ctx context.Context, id any) (runtime.Object, error) {
	return s.XXFindPk(ctx, id)
}

func (s *ProductStorage) FindOne(ctx context.Context) (runtime.Object, error) {
	return s.XXFindOne(ctx)
}

func (s *ProductStorage) Cond(exprs ...clause.Expression) apistorage.Storage {
	return s.XXCond(exprs...)
}

func (s *ProductStorage) Create(ctx context.Context) (runtime.Object, error) {
	return s.XXCreate(ctx)
}

func (s *ProductStorage) Updates(ctx context.Context) (runtime.Object, error) {
	return s.XXUpdates(ctx)
}

func (s *ProductStorage) Delete(ctx context.Context, soft bool) error {
	return s.XXDelete(ctx, soft)
}

func (s *ProductStorage) XXLoad(tx *gorm.DB, in *Product) error {
	s.tx = tx
	s.m = *FromProduct(in)
	return nil
}

func (s *ProductStorage) XXFindPage(ctx context.Context, page, size int32) ([]*Product, int64, error) {
	m := s.m
	pk, _, _ := m.PrimaryKey()

	s.exprs = append(s.exprs,
		clause.OrderBy{Columns: []clause.OrderByColumn{{Column: clause.Column{Table: m.TableName(), Name: pk}, Desc: true}}},
		dao.Cond().Build("inner_deletion_timestamp", 0),
	)

	total, err := s.Count(ctx)
	if err != nil {
		return nil, 0, err
	}

	limit := int(size)
	s.exprs = append(s.exprs, clause.Limit{Offset: int((page - 1) * size), Limit: &limit})
	data, err := s.findAll(ctx)
	if err != nil {
		return nil, 0, err
	}

	return data, total, nil
}

func (s *ProductStorage) XXFindAll(ctx context.Context) ([]*Product, error) {
	s.exprs = append(s.exprs, dao.Cond().Build("inner_deletion_timestamp", 0))
	return s.findAll(ctx)
}

func (s *ProductStorage) XXFindPureAll(ctx context.Context) ([]*Product, error) {
	return s.findAll(ctx)
}

func (s *ProductStorage) findAll(ctx context.Context) ([]*Product, error) {
	dest := make([]*XXProduct, 0)
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(s.extractClauses(tx), s.exprs...)
	for _, item := range s.joins {
		tx = tx.Joins(item)
	}
	if err := tx.Clauses(clauses...).Find(&dest).Error; err != nil {
		return nil, err
	}

	outs := make([]*Product, len(dest))
	for i := range dest {
		outs[i] = dest[i].ToProduct()
	}

	return outs, nil
}

func (s *ProductStorage) Count(ctx context.Context) (total int64, err error) {
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(s.extractClauses(tx), dao.Cond().Build("inner_deletion_timestamp", 0))
	clauses = append(clauses, s.exprs...)

	err = tx.Clauses(clauses...).Count(&total).Error
	return
}

func (s *ProductStorage) XXFindPk(ctx context.Context, id any) (*Product, error) {
	m := s.m
	pk, _, _ := m.PrimaryKey()
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Where(pk+" = ?", id).First(&m).Error; err != nil {
		return nil, err
	}
	return m.ToProduct(), nil
}

func (s *ProductStorage) XXFindOne(ctx context.Context) (*Product, error) {
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	clauses := append(s.extractClauses(tx), dao.Cond().Build("inner_deletion_timestamp", 0))
	clauses = append(clauses, s.exprs...)

	for _, item := range s.joins {
		tx = tx.Joins(item)
	}
	if err := tx.Clauses(clauses...).First(&m).Error; err != nil {
		return nil, err
	}

	return m.ToProduct(), nil
}

func (s *ProductStorage) XXFindPureOne(ctx context.Context) (*Product, error) {
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Clauses(s.exprs...).First(&m).Error; err != nil {
		return nil, err
	}

	return m.ToProduct(), nil
}

func (s *ProductStorage) XXCond(exprs ...clause.Expression) *ProductStorage {
	s.exprs = append(s.exprs, exprs...)
	return s
}

func (s *ProductStorage) extractClauses(tx *gorm.DB) []clause.Expression {
	m := s.m
	exprs := make([]clause.Expression, 0)
	if m.Kind != "" {
		exprs = append(exprs, dao.Cond().Op(dao.ParseOp(m.Kind)).Build("kind", m.Kind))
	}
	if m.ApiVersion != "" {
		exprs = append(exprs, dao.Cond().Op(dao.ParseOp(m.ApiVersion)).Build("api_version", m.ApiVersion))
	}
	if m.Id != "" {
		exprs = append(exprs, dao.Cond().Op(dao.ParseOp(m.Id)).Build("id", m.Id))
	}
	if m.Date != 0 {
		exprs = append(exprs, dao.Cond().Build("date", m.Date))
	}
	if m.Company != "" {
		exprs = append(exprs, dao.Cond().Op(dao.ParseOp(m.Company)).Build("company", m.Company))
	}

	return exprs
}

func (s *ProductStorage) XXCreate(ctx context.Context) (*Product, error) {
	m := s.m
	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	if err := tx.Create(m).Error; err != nil {
		return nil, err
	}

	return m.ToProduct(), nil
}

func (s *ProductStorage) XXUpdates(ctx context.Context) (*Product, error) {
	m := s.m
	pk, pkv, isNil := m.PrimaryKey()
	if isNil {
		return nil, errors.New("missing primary key")
	}

	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx).Where(pk+" = ?", pkv)

	values := make(map[string]interface{}, 0)
	if m.Kind != "" {
		values["kind"] = m.Kind
	}
	if m.ApiVersion != "" {
		values["api_version"] = m.ApiVersion
	}
	if m.Date != 0 {
		values["date"] = m.Date
	}
	if m.Company != "" {
		values["company"] = m.Company
	}

	if err := tx.Updates(values).Error; err != nil {
		return nil, err
	}

	err := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx).Where(pk+" = ?", pkv).First(m).Error
	if err != nil {
		return nil, err
	}
	return m.ToProduct(), nil
}

func (s *ProductStorage) XXDelete(ctx context.Context, soft bool) error {
	m := s.m
	pk, pkv, isNil := m.PrimaryKey()
	if isNil {
		return errors.New("missing primary key")
	}

	tx := s.tx.Session(&gorm.Session{}).Table(m.TableName()).WithContext(ctx)

	if soft {
		return tx.Where(pk+" = ?", pkv).Updates(map[string]interface{}{"inner_deletion_timestamp": time.Now().UnixNano()}).Error
	}
	return tx.Where(pk+" = ?", pkv).Delete(&ProductStorage{}).Error
}
